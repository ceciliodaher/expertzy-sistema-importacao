/**
 * pricing-interface.js - Sistema de Precifica√ß√£o Completo
 *
 * Interface para c√°lculo de custos de importa√ß√£o e forma√ß√£o de pre√ßos
 * PRINC√çPIOS RIGOROSOS:
 * - NO FALLBACKS: Falha expl√≠cita para dados ausentes
 * - NO HARDCODED DATA: Todos os dados vem de arquivos externos ou input do usu√°rio
 * - PORTUGUESE NOMENCLATURE: Seguindo DIProcessor.js
 * - FAIL-FAST VALIDATION: Erro imediato para estruturas inv√°lidas
 *
 * FONTES DE DADOS:
 * - aliquotas.json: Al√≠quotas ICMS por estado
 * - tributacao-monofasica.json: Produtos monof√°sicos
 * - IndexedDB: Dados da DI processada
 * - Input do usu√°rio: Regime tribut√°rio, margens, par√¢metros gerenciais
 */

/**
 * MotorCalculoTributario - C√°lculo de percentuais tribut√°rios baseado em dados externos
 * NO HARDCODED VALUES - todos os dados vem de arquivos JSON ou input do usu√°rio
 */
class MotorCalculoTributario {
    constructor() {
        this.aliquotasData = null;
        this.tributacaoMonofasicaData = null;
        this.initialized = false;
    }

    /**
     * Inicializar motor com carregamento de dados externos - NO FALLBACKS
     */
    async inicializar() {
        if (this.initialized) {
            return; // J√° inicializado
        }

        try {
            // Carregar aliquotas.json - OBRIGAT√ìRIO
            await this.carregarAliquotas();

            // Carregar tributacao-monofasica.json - OBRIGAT√ìRIO
            await this.carregarTributacaoMonofasica();

            this.initialized = true;
            console.log('‚úÖ MotorCalculoTributario inicializado com dados externos');

        } catch (error) {
            throw new Error(`Falha na inicializa√ß√£o do MotorCalculoTributario: ${error.message}`);
        }
    }

    /**
     * Carregar dados de al√≠quotas - FAIL-FAST se arquivo n√£o existir
     */
    async carregarAliquotas() {
        try {
            const response = await fetch(new URL('../../shared/data/aliquotas.json', import.meta.url));
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            this.aliquotasData = await response.json();

            if (!this.aliquotasData.aliquotas_icms_2025) {
                throw new Error('Estrutura inv√°lida: aliquotas_icms_2025 n√£o encontrado');
            }

            console.log('‚úÖ Al√≠quotas ICMS carregadas dos dados oficiais');

        } catch (error) {
            throw new Error(`Erro ao carregar aliquotas.json: ${error.message}`);
        }
    }

    /**
     * Carregar dados de tributa√ß√£o monof√°sica - FAIL-FAST se arquivo n√£o existir
     */
    async carregarTributacaoMonofasica() {
        try {
            const response = await fetch(new URL('../../shared/data/tributacao-monofasica.json', import.meta.url));
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            this.tributacaoMonofasicaData = await response.json();

            if (!this.tributacaoMonofasicaData.regras_credito_por_regime) {
                throw new Error('Estrutura inv√°lida: regras_credito_por_regime n√£o encontrado');
            }

            console.log('‚úÖ Regras de tributa√ß√£o monof√°sica carregadas dos dados oficiais');

        } catch (error) {
            throw new Error(`Erro ao carregar tributacao-monofasica.json: ${error.message}`);
        }
    }

    /**
     * Obter al√≠quota ICMS para estado espec√≠fico - NO FALLBACKS
     * @param {string} estadoUF - C√≥digo UF do estado (obrigat√≥rio)
     * @returns {number} Al√≠quota ICMS + FCP
     */
    obterAliquotaICMS(estadoUF) {
        this.validarInicializacao();

        if (!estadoUF) {
            throw new Error('C√≥digo UF do estado √© obrigat√≥rio para obter al√≠quota ICMS');
        }

        if (typeof estadoUF !== 'string') {
            throw new Error('C√≥digo UF deve ser string');
        }

        const estadoData = this.aliquotasData.aliquotas_icms_2025[estadoUF.toUpperCase()];
        if (!estadoData) {
            throw new Error(`Estado ${estadoUF} n√£o encontrado nos dados de al√≠quotas oficiais`);
        }

        if (typeof estadoData.aliquota_interna !== 'number') {
            throw new Error(`Al√≠quota interna inv√°lida para estado ${estadoUF} - deve ser num√©rica`);
        }

        // Calcular al√≠quota total (ICMS + FCP se aplic√°vel)
        let aliquotaTotal = estadoData.aliquota_interna;

        if (estadoData.fcp !== null) {
            if (typeof estadoData.fcp === 'number') {
                // FCP fixo
                aliquotaTotal += estadoData.fcp;
            } else if (estadoData.fcp && typeof estadoData.fcp.max === 'number') {
                // FCP vari√°vel - usar valor m√°ximo conforme orienta√ß√£o t√©cnica
                aliquotaTotal += estadoData.fcp.max;
            }
        }

        return aliquotaTotal;
    }

    /**
     * Obter regras de cr√©dito para regime tribut√°rio espec√≠fico - NO FALLBACKS
     * @param {string} regimeTributario - lucro_real | lucro_presumido | simples_nacional
     * @returns {Object} Regras de cr√©dito do regime
     */
    obterRegrasCreditoRegime(regimeTributario) {
        this.validarInicializacao();

        if (!regimeTributario) {
            throw new Error('Regime tribut√°rio √© obrigat√≥rio para obter regras de cr√©dito');
        }

        const regimesValidos = ['lucro_real', 'lucro_presumido', 'simples_nacional'];
        if (!regimesValidos.includes(regimeTributario)) {
            throw new Error(`Regime tribut√°rio inv√°lido: ${regimeTributario}. V√°lidos: ${regimesValidos.join(', ')}`);
        }

        const regrasCredito = this.tributacaoMonofasicaData.regras_credito_por_regime[regimeTributario];
        if (!regrasCredito) {
            throw new Error(`Regras de cr√©dito n√£o encontradas para regime ${regimeTributario}`);
        }

        return regrasCredito;
    }

    /**
     * Detectar produtos monof√°sicos em NCM - NO FALLBACKS
     * @param {string} ncm - C√≥digo NCM (obrigat√≥rio)
     * @returns {boolean} Se NCM √© monof√°sico
     */
    detectarMonofasico(ncm) {
        this.validarInicializacao();

        if (!ncm) {
            throw new Error('NCM √© obrigat√≥rio para detec√ß√£o de produto monof√°sico');
        }

        if (typeof ncm !== 'string') {
            throw new Error('NCM deve ser string');
        }

        const padroesMonofasicos = this.tributacaoMonofasicaData.deteccao_automatica?.padroes_ncm_4digitos;
        if (!padroesMonofasicos || !Array.isArray(padroesMonofasicos)) {
            throw new Error('Padr√µes de detec√ß√£o monof√°sica n√£o encontrados nos dados');
        }

        return padroesMonofasicos.some(padrao => ncm.startsWith(padrao));
    }

    /**
     * Calcular percentuais de impostos por dentro para precifica√ß√£o - NO FALLBACKS
     * @param {string} regimeTributario - Regime tribut√°rio da empresa
     * @param {string} estadoUF - Estado para opera√ß√µes internas
     * @param {boolean} isMonofasico - Se produto √© monof√°sico
     * @returns {Object} Percentuais de impostos por dentro
     */
    calcularPercentuaisImpostosPorDentro(regimeTributario, estadoUF, isMonofasico = false) {
        this.validarInicializacao();

        if (!regimeTributario) {
            throw new Error('Regime tribut√°rio √© obrigat√≥rio para c√°lculo de percentuais');
        }

        if (!estadoUF) {
            throw new Error('Estado UF √© obrigat√≥rio para c√°lculo de percentuais');
        }

        // Obter al√≠quota ICMS do estado
        const aliquotaICMS = this.obterAliquotaICMS(estadoUF);

        // Obter regras de cr√©dito do regime
        const regrasCredito = this.obterRegrasCreditoRegime(regimeTributario);

        let percentuais = {
            pis: 0,
            cofins: 0,
            icms: aliquotaICMS,
            ipi: 0, // IPI varia por NCM - deve vir dos dados da DI
            total: aliquotaICMS
        };

        // Calcular PIS/COFINS baseado no regime
        if (regimeTributario === 'simples_nacional') {
            // Simples Nacional: tributa√ß√£o unificada no DAS
            // N√£o h√° PIS/COFINS separados - apenas ICMS nas opera√ß√µes internas
            percentuais.pis = 0;
            percentuais.cofins = 0;

        } else if (regimeTributario === 'lucro_real') {
            // Lucro Real: regime n√£o-cumulativo
            if (isMonofasico) {
                // Produtos monof√°sicos: sem PIS/COFINS na sa√≠da (al√≠quota zero)
                percentuais.pis = 0;
                percentuais.cofins = 0;
            } else {
                // Produtos normais: al√≠quotas padr√£o n√£o-cumulativo
                const aliquotasPadrao = this.aliquotasData.tributos_federais?.pis_cofins_base;
                if (!aliquotasPadrao) {
                    throw new Error('Al√≠quotas padr√£o PIS/COFINS n√£o encontradas nos dados');
                }

                percentuais.pis = aliquotasPadrao.pis_aliquota_basica;
                percentuais.cofins = aliquotasPadrao.cofins_aliquota_basica;
            }

        } else if (regimeTributario === 'lucro_presumido') {
            // Lucro Presumido: regime cumulativo
            if (isMonofasico) {
                // Produtos monof√°sicos: sem PIS/COFINS na sa√≠da
                percentuais.pis = 0;
                percentuais.cofins = 0;
            } else {
                // Produtos normais: al√≠quotas cumulativas (0,65% + 3%)
                percentuais.pis = 0.65;
                percentuais.cofins = 3.00;
            }
        }

        // Calcular total
        percentuais.total = percentuais.pis + percentuais.cofins + percentuais.icms + percentuais.ipi;

        console.log(`üìä Percentuais calculados para ${regimeTributario}/${estadoUF}: ICMS ${percentuais.icms}% + PIS ${percentuais.pis}% + COFINS ${percentuais.cofins}% = ${percentuais.total}%`);

        return percentuais;
    }

    /**
     * Validar se motor foi inicializado - FAIL-FAST
     */
    validarInicializacao() {
        if (!this.initialized) {
            throw new Error('MotorCalculoTributario n√£o foi inicializado - chame inicializar() primeiro');
        }

        if (!this.aliquotasData) {
            throw new Error('Dados de al√≠quotas n√£o carregados - inicializa√ß√£o incompleta');
        }

        if (!this.tributacaoMonofasicaData) {
            throw new Error('Dados de tributa√ß√£o monof√°sica n√£o carregados - inicializa√ß√£o incompleta');
        }
    }
}

/**
 * CalculadoraMetodosPrecificacao - Implementa√ß√£o dos 4 m√©todos de precifica√ß√£o
 * Utiliza f√≥rmulas matem√°ticas exatas conforme especifica√ß√£o t√©cnica
 */
class CalculadoraMetodosPrecificacao {
    constructor(motorTributario) {
        if (!motorTributario) {
            throw new Error('MotorCalculoTributario √© obrigat√≥rio para CalculadoraMetodosPrecificacao');
        }
        this.motorTributario = motorTributario;
    }

    /**
     * M√âTODO 1: M√©todo da Margem
     * F√≥rmula: preco_base = custo_contabil / (1 - margem_desejada - percentual_impostos_por_dentro)
     * @param {number} custoContabil - Custo cont√°bil calculado
     * @param {number} margemDesejada - Margem desejada em decimal (ex: 0.25 para 25%)
     * @param {Object} percentuaisImpostos - Percentuais de impostos por dentro
     * @param {number} aliquotaIPI - Al√≠quota IPI espec√≠fica do produto (se aplic√°vel)
     * @returns {Object} Resultado do m√©todo da margem
     */
    calcularMetodoMargem(custoContabil, margemDesejada, percentuaisImpostos, aliquotaIPI = 0) {
        // Valida√ß√µes NO FALLBACKS
        if (typeof custoContabil !== 'number' || custoContabil <= 0) {
            throw new Error('Custo cont√°bil deve ser num√©rico e positivo para m√©todo da margem');
        }

        if (typeof margemDesejada !== 'number' || margemDesejada < 0 || margemDesejada >= 1) {
            throw new Error('Margem desejada deve ser decimal entre 0 e 1 (ex: 0.25 para 25%)');
        }

        if (!percentuaisImpostos || typeof percentuaisImpostos.total !== 'number') {
            throw new Error('Percentuais de impostos inv√°lidos - total obrigat√≥rio');
        }

        if (typeof aliquotaIPI !== 'number' || aliquotaIPI < 0) {
            throw new Error('Al√≠quota IPI deve ser num√©rica e >= 0');
        }

        // Calcular percentual total de impostos por dentro (em decimal)
        const percentualImpostosPorDentro = percentuaisImpostos.total / 100;

        // Validar se h√° margem suficiente
        const margemMaximaPossivel = 1 - percentualImpostosPorDentro;
        if (margemDesejada >= margemMaximaPossivel) {
            throw new Error(`Margem desejada (${(margemDesejada * 100).toFixed(2)}%) invi√°vel. M√°xima poss√≠vel: ${(margemMaximaPossivel * 100).toFixed(2)}% considerando impostos`);
        }

        // Aplicar f√≥rmula do m√©todo da margem
        const denominador = 1 - margemDesejada - percentualImpostosPorDentro;
        if (denominador <= 0) {
            throw new Error('Denominador inv√°lido na f√≥rmula - margem + impostos excedem 100%');
        }

        const precoBase = custoContabil / denominador;

        // Aplicar IPI se aplic√°vel (IPI √© por fora)
        const precoFinal = precoBase * (1 + (aliquotaIPI / 100));

        // Calcular m√©tricas de resultado
        const valorImpostos = precoBase * percentualImpostosPorDentro;
        const valorMargem = precoBase * margemDesejada;
        const valorIPI = precoBase * (aliquotaIPI / 100);

        return {
            metodo: 'margem',
            custo_contabil: custoContabil,
            preco_base: precoBase,
            preco_final: precoFinal,
            margem_desejada_percentual: margemDesejada * 100,
            margem_valor: valorMargem,
            impostos_valor: valorImpostos,
            ipi_valor: valorIPI,
            percentuais_aplicados: percentuaisImpostos,
            validacao: {
                denominador: denominador,
                margem_maxima_possivel: margemMaximaPossivel * 100
            },
            timestamp: new Date().toISOString()
        };
    }

    /**
     * M√âTODO 2: M√©todo do Markup
     * F√≥rmula: markup_calculado = 100 / (100 - margem_lucro - percentual_impostos_por_dentro)
     * @param {number} custoContabil - Custo cont√°bil calculado
     * @param {number} margemLucro - Margem de lucro desejada em percentual (ex: 25 para 25%)
     * @param {Object} percentuaisImpostos - Percentuais de impostos por dentro
     * @param {number} aliquotaIPI - Al√≠quota IPI espec√≠fica do produto (se aplic√°vel)
     * @returns {Object} Resultado do m√©todo do markup
     */
    calcularMetodoMarkup(custoContabil, margemLucro, percentuaisImpostos, aliquotaIPI = 0) {
        // Valida√ß√µes NO FALLBACKS
        if (typeof custoContabil !== 'number' || custoContabil <= 0) {
            throw new Error('Custo cont√°bil deve ser num√©rico e positivo para m√©todo do markup');
        }

        if (typeof margemLucro !== 'number' || margemLucro < 0 || margemLucro >= 100) {
            throw new Error('Margem de lucro deve ser percentual entre 0 e 100 (ex: 25 para 25%)');
        }

        if (!percentuaisImpostos || typeof percentuaisImpostos.total !== 'number') {
            throw new Error('Percentuais de impostos inv√°lidos - total obrigat√≥rio');
        }

        if (typeof aliquotaIPI !== 'number' || aliquotaIPI < 0) {
            throw new Error('Al√≠quota IPI deve ser num√©rica e >= 0');
        }

        // Validar se h√° margem suficiente
        const margemMaximaPossivel = 100 - percentuaisImpostos.total;
        if (margemLucro >= margemMaximaPossivel) {
            throw new Error(`Margem de lucro (${margemLucro}%) invi√°vel. M√°xima poss√≠vel: ${margemMaximaPossivel.toFixed(2)}% considerando impostos`);
        }

        // Aplicar f√≥rmula do m√©todo do markup
        const denominador = 100 - margemLucro - percentuaisImpostos.total;
        if (denominador <= 0) {
            throw new Error('Denominador inv√°lido na f√≥rmula - margem + impostos excedem 100%');
        }

        const markupCalculado = 100 / denominador;
        const precoBase = custoContabil * markupCalculado;

        // Aplicar IPI se aplic√°vel (IPI √© por fora)
        const precoFinal = precoBase * (1 + (aliquotaIPI / 100));

        // Calcular m√©tricas de resultado
        const valorImpostos = precoBase * (percentuaisImpostos.total / 100);
        const valorMargem = precoBase * (margemLucro / 100);
        const valorIPI = precoBase * (aliquotaIPI / 100);

        return {
            metodo: 'markup',
            custo_contabil: custoContabil,
            markup_calculado: markupCalculado,
            preco_base: precoBase,
            preco_final: precoFinal,
            margem_lucro_percentual: margemLucro,
            margem_valor: valorMargem,
            impostos_valor: valorImpostos,
            ipi_valor: valorIPI,
            percentuais_aplicados: percentuaisImpostos,
            validacao: {
                denominador: denominador,
                margem_maxima_possivel: margemMaximaPossivel
            },
            timestamp: new Date().toISOString()
        };
    }

    /**
     * M√âTODO 3: Divis√£o
     * F√≥rmula: preco_final = custo_contabil / (1 - percentual_total_impostos_margem)
     * @param {number} custoContabil - Custo cont√°bil calculado
     * @param {number} percentualTotal - Percentual total (impostos + margem) em decimal
     * @param {number} aliquotaIPI - Al√≠quota IPI espec√≠fica do produto (se aplic√°vel)
     * @returns {Object} Resultado do m√©todo divis√£o
     */
    calcularMetodoDivisao(custoContabil, percentualTotal, aliquotaIPI = 0) {
        // Valida√ß√µes NO FALLBACKS
        if (typeof custoContabil !== 'number' || custoContabil <= 0) {
            throw new Error('Custo cont√°bil deve ser num√©rico e positivo para m√©todo da divis√£o');
        }

        if (typeof percentualTotal !== 'number' || percentualTotal <= 0 || percentualTotal >= 1) {
            throw new Error('Percentual total deve ser decimal entre 0 e 1 (ex: 0.4 para 40%)');
        }

        if (typeof aliquotaIPI !== 'number' || aliquotaIPI < 0) {
            throw new Error('Al√≠quota IPI deve ser num√©rica e >= 0');
        }

        // Aplicar f√≥rmula da divis√£o
        const denominador = 1 - percentualTotal;
        if (denominador <= 0) {
            throw new Error('Denominador inv√°lido - percentual total >= 100%');
        }

        const precoBase = custoContabil / denominador;

        // Aplicar IPI se aplic√°vel (IPI √© por fora)
        const precoFinal = precoBase * (1 + (aliquotaIPI / 100));

        // Calcular m√©tricas de resultado
        const valorImpostosMargem = precoBase * percentualTotal;
        const valorIPI = precoBase * (aliquotaIPI / 100);

        return {
            metodo: 'divisao',
            custo_contabil: custoContabil,
            percentual_total_decimal: percentualTotal,
            percentual_total_percentual: percentualTotal * 100,
            preco_base: precoBase,
            preco_final: precoFinal,
            valor_impostos_margem: valorImpostosMargem,
            ipi_valor: valorIPI,
            validacao: {
                denominador: denominador
            },
            timestamp: new Date().toISOString()
        };
    }

    /**
     * M√âTODO 4: Multiplica√ß√£o (Factor)
     * F√≥rmula: preco_final = custo_contabil * fator_multiplicador
     * @param {number} custoContabil - Custo cont√°bil calculado
     * @param {number} fatorMultiplicador - Fator de multiplica√ß√£o (ex: 1.67 para markup de 67%)
     * @param {number} aliquotaIPI - Al√≠quota IPI espec√≠fica do produto (se aplic√°vel)
     * @returns {Object} Resultado do m√©todo multiplica√ß√£o
     */
    calcularMetodoMultiplicacao(custoContabil, fatorMultiplicador, aliquotaIPI = 0) {
        // Valida√ß√µes NO FALLBACKS
        if (typeof custoContabil !== 'number' || custoContabil <= 0) {
            throw new Error('Custo cont√°bil deve ser num√©rico e positivo para m√©todo da multiplica√ß√£o');
        }

        if (typeof fatorMultiplicador !== 'number' || fatorMultiplicador <= 1) {
            throw new Error('Fator multiplicador deve ser num√©rico e > 1 (ex: 1.67 para markup de 67%)');
        }

        if (typeof aliquotaIPI !== 'number' || aliquotaIPI < 0) {
            throw new Error('Al√≠quota IPI deve ser num√©rica e >= 0');
        }

        // Aplicar f√≥rmula da multiplica√ß√£o
        const precoBase = custoContabil * fatorMultiplicador;

        // Aplicar IPI se aplic√°vel (IPI √© por fora)
        const precoFinal = precoBase * (1 + (aliquotaIPI / 100));

        // Calcular m√©tricas de resultado
        const valorMarkup = precoBase - custoContabil;
        const percentualMarkup = ((precoBase - custoContabil) / custoContabil) * 100;
        const margemBruta = (valorMarkup / precoBase) * 100;
        const valorIPI = precoBase * (aliquotaIPI / 100);

        return {
            metodo: 'multiplicacao',
            custo_contabil: custoContabil,
            fator_multiplicador: fatorMultiplicador,
            preco_base: precoBase,
            preco_final: precoFinal,
            valor_markup: valorMarkup,
            percentual_markup: percentualMarkup,
            margem_bruta_percentual: margemBruta,
            ipi_valor: valorIPI,
            timestamp: new Date().toISOString()
        };
    }
}

/**
 * ValidadorParametros - Valida√ß√£o rigorosa de par√¢metros de entrada - NO FALLBACKS
 */
class ValidadorParametros {
    /**
     * Validar dados da DI carregados do IndexedDB
     * @param {Object} diData - Dados da DI
     * @returns {Object} Estrutura validada
     */
    static validarDadosDI(diData) {
        if (!diData) {
            throw new Error('Dados da DI s√£o obrigat√≥rios - n√£o fornecidos');
        }

        if (typeof diData !== 'object') {
            throw new Error('Dados da DI devem ser um objeto v√°lido');
        }

        // Validar campos obrigat√≥rios b√°sicos
        const camposObrigatorios = ['numero_di', 'adicoes', 'totais'];
        for (const campo of camposObrigatorios) {
            if (!diData[campo]) {
                throw new Error(`Campo obrigat√≥rio ausente nos dados da DI: ${campo}`);
            }
        }

        // Validar n√∫mero da DI
        if (typeof diData.numero_di !== 'string' || diData.numero_di.trim().length === 0) {
            throw new Error('N√∫mero da DI deve ser uma string n√£o-vazia');
        }

        // Validar adi√ß√µes
        if (!Array.isArray(diData.adicoes) || diData.adicoes.length === 0) {
            throw new Error('DI deve ter pelo menos uma adi√ß√£o v√°lida');
        }

        // Validar totais
        if (typeof diData.totais !== 'object') {
            throw new Error('Totais da DI devem ser um objeto v√°lido');
        }

        const camposTotaisObrigatorios = ['valor_aduaneiro', 'ii_devido', 'ipi_devido', 'pis_devido', 'cofins_devido', 'icms_devido', 'despesas_aduaneiras'];
        for (const campo of camposTotaisObrigatorios) {
            if (typeof diData.totais[campo] !== 'number') {
                throw new Error(`Campo total obrigat√≥rio inv√°lido: ${campo} deve ser num√©rico`);
            }
        }

        console.log('‚úÖ Dados da DI validados com sucesso');
        return diData;
    }

    /**
     * Validar regime tribut√°rio
     * @param {string} regimeTributario - Regime tribut√°rio
     * @returns {string} Regime validado
     */
    static validarRegimeTributario(regimeTributario) {
        if (!regimeTributario) {
            throw new Error('Regime tribut√°rio √© obrigat√≥rio - n√£o fornecido pelo usu√°rio');
        }

        if (typeof regimeTributario !== 'string') {
            throw new Error('Regime tribut√°rio deve ser uma string');
        }

        const regimesValidos = ['lucro_real', 'lucro_presumido', 'simples_nacional'];
        if (!regimesValidos.includes(regimeTributario)) {
            throw new Error(`Regime tribut√°rio inv√°lido: ${regimeTributario}. V√°lidos: ${regimesValidos.join(', ')}`);
        }

        return regimeTributario;
    }

    /**
     * Validar estado UF
     * @param {string} estadoUF - C√≥digo UF do estado
     * @returns {string} Estado validado
     */
    static validarEstadoUF(estadoUF) {
        if (!estadoUF) {
            throw new Error('Estado UF √© obrigat√≥rio - n√£o fornecido pelo usu√°rio');
        }

        if (typeof estadoUF !== 'string') {
            throw new Error('Estado UF deve ser uma string');
        }

        if (estadoUF.length !== 2) {
            throw new Error('Estado UF deve ter exatamente 2 caracteres');
        }

        return estadoUF.toUpperCase();
    }

    /**
     * Validar par√¢metros gerenciais do usu√°rio
     * @param {Object} parametros - Par√¢metros gerenciais
     * @returns {Object} Par√¢metros validados
     */
    static validarParametrosGerenciais(parametros) {
        if (!parametros) {
            throw new Error('Par√¢metros gerenciais s√£o obrigat√≥rios - devem ser preenchidos pelo usu√°rio');
        }

        if (typeof parametros !== 'object') {
            throw new Error('Par√¢metros gerenciais devem ser um objeto v√°lido');
        }

        // Validar encargos financeiros
        if (typeof parametros.encargos_financeiros_percentual !== 'number') {
            throw new Error('Encargos financeiros (%) √© obrigat√≥rio - deve ser preenchido pelo usu√°rio');
        }

        if (parametros.encargos_financeiros_percentual < 0 || parametros.encargos_financeiros_percentual > 100) {
            throw new Error('Encargos financeiros deve estar entre 0 e 100%');
        }

        // Validar tributos recuper√°veis
        if (typeof parametros.tributos_recuperaveis_outros !== 'number') {
            throw new Error('Tributos recuper√°veis outros √© obrigat√≥rio - deve ser preenchido pelo usu√°rio');
        }

        if (parametros.tributos_recuperaveis_outros < 0) {
            throw new Error('Tributos recuper√°veis outros deve ser >= 0');
        }

        // Validar custos indiretos
        if (typeof parametros.custos_indiretos_percentual !== 'number') {
            throw new Error('Custos indiretos (%) √© obrigat√≥rio - deve ser preenchido pelo usu√°rio');
        }

        if (parametros.custos_indiretos_percentual < 0 || parametros.custos_indiretos_percentual > 100) {
            throw new Error('Custos indiretos deve estar entre 0 e 100%');
        }

        // Validar margem operacional
        if (typeof parametros.margem_operacional_percentual !== 'number') {
            throw new Error('Margem operacional (%) √© obrigat√≥rio - deve ser preenchido pelo usu√°rio');
        }

        if (parametros.margem_operacional_percentual < 0 || parametros.margem_operacional_percentual > 1000) {
            throw new Error('Margem operacional deve estar entre 0 e 1000%');
        }

        console.log('‚úÖ Par√¢metros gerenciais validados com sucesso');
        return parametros;
    }

    /**
     * Validar par√¢metros de precifica√ß√£o
     * @param {Object} parametrosPrecificacao - Par√¢metros de precifica√ß√£o
     * @returns {Object} Par√¢metros validados
     */
    static validarParametrosPrecificacao(parametrosPrecificacao) {
        if (!parametrosPrecificacao) {
            throw new Error('Par√¢metros de precifica√ß√£o s√£o obrigat√≥rios - devem ser preenchidos pelo usu√°rio');
        }

        if (typeof parametrosPrecificacao !== 'object') {
            throw new Error('Par√¢metros de precifica√ß√£o devem ser um objeto v√°lido');
        }

        // Validar m√©todo selecionado
        const metodosValidos = ['margem', 'markup', 'divisao', 'multiplicacao'];
        if (!parametrosPrecificacao.metodo || !metodosValidos.includes(parametrosPrecificacao.metodo)) {
            throw new Error(`M√©todo de precifica√ß√£o inv√°lido. V√°lidos: ${metodosValidos.join(', ')}`);
        }

        // Valida√ß√µes espec√≠ficas por m√©todo
        switch (parametrosPrecificacao.metodo) {
            case 'margem':
                if (typeof parametrosPrecificacao.margem_desejada !== 'number') {
                    throw new Error('Margem desejada √© obrigat√≥ria para m√©todo da margem');
                }
                if (parametrosPrecificacao.margem_desejada <= 0 || parametrosPrecificacao.margem_desejada >= 100) {
                    throw new Error('Margem desejada deve estar entre 0 e 100%');
                }
                break;

            case 'markup':
                if (typeof parametrosPrecificacao.margem_lucro !== 'number') {
                    throw new Error('Margem de lucro √© obrigat√≥ria para m√©todo do markup');
                }
                if (parametrosPrecificacao.margem_lucro <= 0 || parametrosPrecificacao.margem_lucro >= 100) {
                    throw new Error('Margem de lucro deve estar entre 0 e 100%');
                }
                break;

            case 'divisao':
                if (typeof parametrosPrecificacao.percentual_total !== 'number') {
                    throw new Error('Percentual total √© obrigat√≥rio para m√©todo da divis√£o');
                }
                if (parametrosPrecificacao.percentual_total <= 0 || parametrosPrecificacao.percentual_total >= 100) {
                    throw new Error('Percentual total deve estar entre 0 e 100%');
                }
                break;

            case 'multiplicacao':
                if (typeof parametrosPrecificacao.fator_multiplicador !== 'number') {
                    throw new Error('Fator multiplicador √© obrigat√≥rio para m√©todo da multiplica√ß√£o');
                }
                if (parametrosPrecificacao.fator_multiplicador <= 1) {
                    throw new Error('Fator multiplicador deve ser > 1');
                }
                break;
        }

        console.log('‚úÖ Par√¢metros de precifica√ß√£o validados com sucesso');
        return parametrosPrecificacao;
    }
}

/**
 * InterfacePrecificacao - Classe principal de orquestra√ß√£o
 * Coordena todos os componentes do sistema de precifica√ß√£o
 */
class InterfacePrecificacao {
    constructor() {
        this.motorTributario = new MotorCalculoTributario();
        this.calculadora = null;
        this.dadosDI = null;
        this.custos4Tipos = null;
        this.resultadosPrecificacao = null;
        this.initialized = false;
    }

    /**
     * Inicializar sistema completo de precifica√ß√£o
     */
    async inicializar() {
        if (this.initialized) {
            return;
        }

        try {
            console.log('üöÄ Inicializando sistema de precifica√ß√£o...');

            // Inicializar motor tribut√°rio com dados externos
            await this.motorTributario.inicializar();

            // Criar calculadora
            this.calculadora = new CalculadoraMetodosPrecificacao(this.motorTributario);

            this.initialized = true;
            console.log('‚úÖ Sistema de precifica√ß√£o inicializado com sucesso');

        } catch (error) {
            throw new Error(`Falha na inicializa√ß√£o do sistema de precifica√ß√£o: ${error.message}`);
        }
    }

    /**
     * Carregar dados da DI do IndexedDB - INTEGRA√á√ÉO OBRIGAT√ìRIA
     * @param {Object} dadosDI - Dados da DI processados na Fase 1
     */
    carregarDadosDI(dadosDI) {
        this.validarInicializacao();

        // Validar estrutura da DI rigorosamente
        this.dadosDI = ValidadorParametros.validarDadosDI(dadosDI);

        console.log(`‚úÖ Dados da DI ${this.dadosDI.numero_di} carregados para precifica√ß√£o`);
    }

    /**
     * Calcular os 4 tipos de custos conforme PricingEngine
     * @param {string} regimeTributario - Regime tribut√°rio da empresa
     * @param {Object} parametrosGerenciais - Par√¢metros preenchidos pelo usu√°rio
     * @returns {Object} Resultado dos 4 tipos de custos
     */
    async calcular4TiposCustos(regimeTributario, parametrosGerenciais) {
        this.validarInicializacao();

        if (!this.dadosDI) {
            throw new Error('Dados da DI n√£o carregados - use carregarDadosDI() primeiro');
        }

        // Validar par√¢metros de entrada
        const regimeValidado = ValidadorParametros.validarRegimeTributario(regimeTributario);
        const parametrosValidados = ValidadorParametros.validarParametrosGerenciais(parametrosGerenciais);

        try {
            console.log('üè≠ Calculando os 4 tipos de custos...');

            // TIPO 1: Custo Base (valor_aduaneiro + impostos + despesas)
            const custoBase = this.calcularCustoBase();

            // TIPO 2: Custo de Desembolso (custo_base - cr√©ditos)
            const custoDesembolso = await this.calcularCustoDesembolso(custoBase, regimeValidado);

            // TIPO 3: Custo Cont√°bil (custo_desembolso + encargos - recuper√°veis)
            const custoContabil = this.calcularCustoContabil(custoDesembolso, parametrosValidados);

            // TIPO 4: Base para Forma√ß√£o de Pre√ßo (custo_cont√°bil + indiretos + margem operacional)
            const baseFormacaoPreco = this.calcularBaseFormacaoPreco(custoContabil, parametrosValidados);

            // Estruturar resultado completo
            this.custos4Tipos = {
                tipo_1_custo_base: custoBase,
                tipo_2_custo_desembolso: custoDesembolso,
                tipo_3_custo_contabil: custoContabil,
                tipo_4_base_formacao_preco: baseFormacaoPreco,
                regime_tributario: regimeValidado,
                parametros_utilizados: parametrosValidados,
                di_numero: this.dadosDI.numero_di,
                timestamp: new Date().toISOString()
            };

            console.log(`‚úÖ 4 tipos de custos calculados: Base R$ ${custoBase.toFixed(2)} ‚Üí Desembolso R$ ${custoDesembolso.toFixed(2)} ‚Üí Cont√°bil R$ ${custoContabil.toFixed(2)} ‚Üí Forma√ß√£o Pre√ßo R$ ${baseFormacaoPreco.toFixed(2)}`);

            return this.custos4Tipos;

        } catch (error) {
            throw new Error(`Erro no c√°lculo dos 4 tipos de custos: ${error.message}`);
        }
    }

    /**
     * Gerar pre√ßos pelos 4 m√©todos de precifica√ß√£o
     * @param {string} estadoUF - Estado para opera√ß√µes de venda
     * @param {Object} parametrosPrecificacao - Par√¢metros espec√≠ficos por m√©todo
     * @returns {Object} Pre√ßos calculados pelos 4 m√©todos
     */
    async gerarPrecos4Metodos(estadoUF, parametrosPrecificacao) {
        this.validarInicializacao();

        if (!this.custos4Tipos) {
            throw new Error('4 tipos de custos n√£o calculados - use calcular4TiposCustos() primeiro');
        }

        // Validar par√¢metros
        const estadoValidado = ValidadorParametros.validarEstadoUF(estadoUF);
        const parametrosValidados = ValidadorParametros.validarParametrosPrecificacao(parametrosPrecificacao);

        try {
            console.log('üí∞ Gerando pre√ßos pelos 4 m√©todos de precifica√ß√£o...');

            // Obter custo cont√°bil para base dos c√°lculos
            const custoContabil = this.custos4Tipos.tipo_3_custo_contabil;

            // Detectar se produtos s√£o monof√°sicos
            const ncmPrincipal = this.dadosDI.adicoes[0].ncm;
            const isMonofasico = this.motorTributario.detectarMonofasico(ncmPrincipal);

            // Obter percentuais de impostos por dentro para o estado
            const percentuaisImpostos = this.motorTributario.calcularPercentuaisImpostosPorDentro(
                this.custos4Tipos.regime_tributario,
                estadoValidado,
                isMonofasico
            );

            // Obter al√≠quota IPI (se aplic√°vel) dos dados da DI
            const aliquotaIPI = this.dadosDI.adicoes[0].ipi_aliquota_ad_valorem || 0;

            let resultados = {};

            // M√âTODO 1: Margem (se parametros fornecidos)
            if (parametrosValidados.margem_desejada !== undefined) {
                resultados.metodo_margem = this.calculadora.calcularMetodoMargem(
                    custoContabil,
                    parametrosValidados.margem_desejada / 100, // Converter para decimal
                    percentuaisImpostos,
                    aliquotaIPI
                );
            }

            // M√âTODO 2: Markup (se parametros fornecidos)
            if (parametrosValidados.margem_lucro !== undefined) {
                resultados.metodo_markup = this.calculadora.calcularMetodoMarkup(
                    custoContabil,
                    parametrosValidados.margem_lucro,
                    percentuaisImpostos,
                    aliquotaIPI
                );
            }

            // M√âTODO 3: Divis√£o (se parametros fornecidos)
            if (parametrosValidados.percentual_total !== undefined) {
                resultados.metodo_divisao = this.calculadora.calcularMetodoDivisao(
                    custoContabil,
                    parametrosValidados.percentual_total / 100, // Converter para decimal
                    aliquotaIPI
                );
            }

            // M√âTODO 4: Multiplica√ß√£o (se parametros fornecidos)
            if (parametrosValidados.fator_multiplicador !== undefined) {
                resultados.metodo_multiplicacao = this.calculadora.calcularMetodoMultiplicacao(
                    custoContabil,
                    parametrosValidados.fator_multiplicador,
                    aliquotaIPI
                );
            }

            // Estruturar resultado final
            this.resultadosPrecificacao = {
                custos_base: this.custos4Tipos,
                metodos_precificacao: resultados,
                configuracao: {
                    estado_uf: estadoValidado,
                    ncm_principal: ncmPrincipal,
                    is_monofasico: isMonofasico,
                    aliquota_ipi: aliquotaIPI,
                    percentuais_impostos: percentuaisImpostos
                },
                parametros_aplicados: parametrosValidados,
                timestamp: new Date().toISOString()
            };

            console.log(`‚úÖ Pre√ßos gerados pelos m√©todos especificados para estado ${estadoValidado}`);

            return this.resultadosPrecificacao;

        } catch (error) {
            throw new Error(`Erro na gera√ß√£o de pre√ßos: ${error.message}`);
        }
    }

    /**
     * TIPO 1: Calcular Custo Base
     * F√≥rmula: valor_aduaneiro + II + IPI + PIS + COFINS + ICMS + despesas_aduaneiras
     */
    calcularCustoBase() {
        const totais = this.dadosDI.totais;

        const custoBase =
            totais.valor_aduaneiro +
            totais.ii_devido +
            totais.ipi_devido +
            totais.pis_devido +
            totais.cofins_devido +
            totais.icms_devido +
            totais.despesas_aduaneiras;

        console.log(`üí∞ Custo Base: R$ ${custoBase.toFixed(2)}`);
        return custoBase;
    }

    /**
     * TIPO 2: Calcular Custo de Desembolso
     * F√≥rmula: custo_base - cr√©ditos_tribut√°rios
     */
    async calcularCustoDesembolso(custoBase, regimeTributario) {
        const totais = this.dadosDI.totais;

        // Base para cr√©ditos: valor_aduaneiro + IPI (sem despesas aduaneiras)
        const baseCreditos = totais.valor_aduaneiro + totais.ipi_devido;

        let totalCreditos = 0;

        // Calcular cr√©ditos por regime
        const regrasCredito = this.motorTributario.obterRegrasCreditoRegime(regimeTributario);

        if (regimeTributario === 'lucro_real') {
            // Lucro Real: cr√©dito integral mesmo para monof√°sicos
            if (regrasCredito.permite_credito_importacao) {
                totalCreditos += totais.pis_devido;
                totalCreditos += totais.cofins_devido;
                totalCreditos += totais.ipi_devido;
                totalCreditos += totais.icms_devido;
            }
        } else if (regimeTributario === 'lucro_presumido') {
            // Lucro Presumido: sem cr√©ditos PIS/COFINS, mas permite IPI e ICMS
            totalCreditos += totais.ipi_devido;
            totalCreditos += totais.icms_devido;
        }
        // Simples Nacional: sem cr√©ditos

        const custoDesembolso = custoBase - totalCreditos;

        console.log(`üí≥ Custo Desembolso: R$ ${custoDesembolso.toFixed(2)} (cr√©ditos: R$ ${totalCreditos.toFixed(2)})`);
        return custoDesembolso;
    }

    /**
     * TIPO 3: Calcular Custo Cont√°bil
     * F√≥rmula: custo_desembolso + encargos_financeiros - tributos_recuper√°veis
     */
    calcularCustoContabil(custoDesembolso, parametrosGerenciais) {
        const encargosFinanceiros = custoDesembolso * (parametrosGerenciais.encargos_financeiros_percentual / 100);
        const tributosRecuperaveis = parametrosGerenciais.tributos_recuperaveis_outros;

        const custoContabil = custoDesembolso + encargosFinanceiros - tributosRecuperaveis;

        console.log(`üìä Custo Cont√°bil: R$ ${custoContabil.toFixed(2)}`);
        return custoContabil;
    }

    /**
     * TIPO 4: Calcular Base para Forma√ß√£o de Pre√ßo
     * F√≥rmula: custo_cont√°bil + custos_indiretos + margem_operacional
     */
    calcularBaseFormacaoPreco(custoContabil, parametrosGerenciais) {
        const custosIndiretos = custoContabil * (parametrosGerenciais.custos_indiretos_percentual / 100);
        const margemOperacional = custoContabil * (parametrosGerenciais.margem_operacional_percentual / 100);

        const baseFormacaoPreco = custoContabil + custosIndiretos + margemOperacional;

        console.log(`üéØ Base Forma√ß√£o Pre√ßo: R$ ${baseFormacaoPreco.toFixed(2)}`);
        return baseFormacaoPreco;
    }

    /**
     * Obter resumo de resultados para interface
     */
    obterResumoResultados() {
        if (!this.resultadosPrecificacao) {
            throw new Error('Nenhum resultado de precifica√ß√£o dispon√≠vel');
        }

        const custos = this.custos4Tipos;
        const metodos = this.resultadosPrecificacao.metodos_precificacao;

        // Preparar resumo dos m√©todos calculados
        let resumoMetodos = {};

        if (metodos.metodo_margem) {
            resumoMetodos.margem = {
                nome: 'M√©todo da Margem',
                preco_final: metodos.metodo_margem.preco_final,
                margem_percentual: metodos.metodo_margem.margem_desejada_percentual
            };
        }

        if (metodos.metodo_markup) {
            resumoMetodos.markup = {
                nome: 'M√©todo do Markup',
                preco_final: metodos.metodo_markup.preco_final,
                markup_calculado: metodos.metodo_markup.markup_calculado
            };
        }

        if (metodos.metodo_divisao) {
            resumoMetodos.divisao = {
                nome: 'M√©todo da Divis√£o',
                preco_final: metodos.metodo_divisao.preco_final,
                percentual_total: metodos.metodo_divisao.percentual_total_percentual
            };
        }

        if (metodos.metodo_multiplicacao) {
            resumoMetodos.multiplicacao = {
                nome: 'M√©todo da Multiplica√ß√£o',
                preco_final: metodos.metodo_multiplicacao.preco_final,
                fator: metodos.metodo_multiplicacao.fator_multiplicador
            };
        }

        return {
            di_numero: this.dadosDI.numero_di,
            custos_4_tipos: {
                custo_base: custos.tipo_1_custo_base,
                custo_desembolso: custos.tipo_2_custo_desembolso,
                custo_contabil: custos.tipo_3_custo_contabil,
                base_formacao_preco: custos.tipo_4_base_formacao_preco
            },
            metodos_precificacao: resumoMetodos,
            configuracao: this.resultadosPrecificacao.configuracao,
            timestamp: this.resultadosPrecificacao.timestamp
        };
    }

    /**
     * Validar se sistema foi inicializado
     */
    validarInicializacao() {
        if (!this.initialized) {
            throw new Error('Sistema de precifica√ß√£o n√£o foi inicializado - chame inicializar() primeiro');
        }

        if (!this.motorTributario || !this.calculadora) {
            throw new Error('Componentes do sistema n√£o est√£o dispon√≠veis - inicializa√ß√£o incompleta');
        }
    }
}

// Exportar classes para uso global
if (typeof window !== 'undefined') {
    window.MotorCalculoTributario = MotorCalculoTributario;
    window.CalculadoraMetodosPrecificacao = CalculadoraMetodosPrecificacao;
    window.ValidadorParametros = ValidadorParametros;
    window.InterfacePrecificacao = InterfacePrecificacao;
}

// Export para m√≥dulos ES6
export {
    MotorCalculoTributario,
    CalculadoraMetodosPrecificacao,
    ValidadorParametros,
    InterfacePrecificacao
};